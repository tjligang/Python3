tags: 函数

[TOC]

# 内置函数

> [Doc : build in functions][1]

# 参数的调用

传值还是传引用？是**“传对象引用”**！

重要概念：Python中的**变量**和**对象**。 

 - 变量：Python中的变量是没有类型的，我们可以把它看做一个(*void)类型的指针，变量是可以指向任何对象的，而对象才是有类型的。变量中保存的是对象的内存地址。 
 - 对象：Python中的对象是一个内存空间，其中保存数据，根据内存区域是否可以被修改，分为可变对象（list，dict等）和不可变对象（number，string，tuple等）。

函数参数传递是变量的值（不是变量自身的内存地址），即变量所指向对象的内存地址，称为**传对象引用**。 

对于不可变对象和可变对象，python处理方式不同：

 - 不可变对象作为函数参数

所有试图修改不可变对象的操作，都会导致对象创建复本，修改对复本进行，参数变量指向复本对象的内存地址，原始对象不变，相当于C系语言的值传递。 

 - 可变对象作为函数参数

所有试图修改可变对象的操作，都直接对可变对象进行，参数变量依然指向该对象的内存地址，原始对象改变，相当于C系语言的引用传递。 

python使用“传对象引用”的方式，不允许程序员选择采用传值还是传引用。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值”来传递对象。

> [参考1][2]
> [参考2][3]
> [deep copy][4]
> [深入理解][5]

# 参数的类型

> [廖雪峰：函数的参数][6]

## 普通参数（Regular Argument）

调用函数时，传入确定数量的参数，可使用普通参数定义，在定义时明确参数的数量、类型和顺序，调用参数时，使用位置参数或者关键字参数。

### 定义函数

普通参数根据定义时是否提供默认值，可分为：

 - 必选参数：定义时不提供默认值
 - 默认参数：定义时提供默认值

参数定义顺序：必选参数在前，默认参数在后，否则python在调用函数时，无法分辨提供的参数值是用来替换前面默认参数的默认值，还是给后面的必选参数。

### 调用函数

 - 位置参数法：按照参数定义的顺序提供参数值，前面的必选参数必须提供值，后面的默认参数可省略（用默认值替代）。
 - 关键字参数法：按照`argument=value`的方式提供参数值，不必和参数定义顺序相同，但必选参数必须提供值，默认参数可省略。

位置参数法和关键字参数法可以混用（不建议），但必须保证所有位置参数在前并且和定义顺序相同，关键字参数在后，可打乱顺序。如果关键字参数后又出现位置参数，python无法分辨位置参数的正确顺序，会报错。

## 可变参数（Varargs Argument）

**参数数量不确定**，定义函数时可使用`*args`表示任意数量参数。这些参数没有参数名，无法使用关键字参数法逐个指定，只能通过位置参数法**批量处理**。

### 定义函数

定义函数时，传入的参数数量不确定，可以使用`*args`表示所有不确定的参数。可变参数中的单个参数是没有对应参数名的。在函数内部会将这些不确定的参数值组装成tuple，通过for循环逐一处理。

参数定义顺序：必选参数-默认值参数-可变参数。可变参数会“吞噬”所有传入的剩余参数值，在可变参数右侧的普通参数无法被赋值。

### 调用函数

可变参数通过`*args`定义，这些参数是没有参数名的，因此调用函数时，必须使用位置参数法。所有参数值必须按照定义顺序（必选参数-默认值参数-可变参数）严格按照位置传入，不允许在任何位置使用关键字参数，默认值参数也不能省略，即使这次调用函数使用的就是默认值，任何组合都不可以，否则都会导致python无法按正确顺序解读参数。可变参数可以看作是位置参数法对不确定数量参数的扩展。

`*args`将所有传入的参数值组装成一个tuple，可通过for循环逐一处理。如果试图直接通过传入一个list来表示多个参数，可以通过`list[index]`拆分成单一参数传入，或者可以使用`*list`方式进行解包（Unpacking Argument          Lists），解包后的单个列表元素传入函数中后，会再次被组合成tuple。

## 关键字参数（Keyword Argument）

**参数数量不确定**，但处理参数时，需要通过参数名**逐一处理**，定义函数时可使用`**kwargs`表示任意数量“参数名/参数值”对（key/value对）。例如在注册个人信息时，函数处理附加可选信息时，不但要知道参数值'beijing'，还要知道它的含义即参数名'city'。

### 定义函数

定义函数时，传入的参数数量不确定，但需要指定参数名以便逐一处理，可以使用`**kwargs`表示任意的含参数名的参数值，即“参数名/参数值”对。关键字参数中的每一个参数值都有对应参数名，在函数内部会将这些参数名和参数值组装成key/value对，保存在dict中，通过for循环逐一处理。

参数定义顺序：必选参数-默认值参数-可变参数-关键字参数。可变参数会“吞噬”所有剩余的没有参数名的参数值，关键字参数会“吞噬”可变参数后面所有有参数名的参数值。

调用函数时，必选参数，默认值参数，可变参数必须通过位置参数法调用，关键字参数必须通过关键字参数法调用，python要求所有位置参数在前，关键字参数在后，所以定义时，关键字参数必须在最后。

### 调用函数

关键字参数通过`**kwargs`定义，这些参数值都有参数名，调用函数时，必须使关键字参数法。所有参数值必须严格按照定义顺序传入（必选参数-默认值参数-可变参数-关键字参数），必选/默认值/可变参数必须使用位置参数法，关键字参数必须使用关键字参数法。这样的要求是因为可变参数没有参数名，只能通过位置调用，而python要求所有位置参数在前，关键字参数在后，所以必选/默认值/可变参数都必须使用位置调用。关键字参数可以看作是关键字参数法对不确定数量参数的扩展。

如果函数中只包含：必选参数-默认值参数-关键字参数，调用函数时，可以通过关键字参数法打乱顺序，因为所有参数都有参数名，可以准确区分。如果混用位置参数法和关键字参数法，依然要保证位置参数在前，关键字参数在后。

`**kwargs`将所有传入的“参数名/参数值”对看成一个个key/value对，在函数内部组装成dict，再通过for循环逐一处理。如果试图直接通过传入一个dict来表示多个“参数名/参数值”对，可以通过`key=dict[key]`拆分成多个“参数名/参数值”对传入，或者可以使用`**dict`方式进行解包（Unpacking Argument Lists），解包后的多个“参数名/参数值”对传入函数中后，会再次被组合成dict。

## 仅关键字参数（Keyword-Only Argument）

> [PEP 3102 -- Keyword-Only Arguments][7]

### 定义函数

当函数的参数具有以下两个特征时，传统的参数定义和调用会非常不方便，仅关键字参数针对这两种情况，给出两个解决方案：

 - 不确定数量的参数 + 确定数量的选项：`func(*args, arg=val)`
 可变参数`*args`后面的参数必须通过关键字参数法调用，可提供默认值。
 - 确定数量的普通参数 + 确定数量的额外选项：`func(arg1=val1, *, arg2=val2)`
 `*`后面的参数必须通过关键字参数法调用，注意*只是一个分隔符，不是参数，func()只接受两个参数。

### 调用参数

传入参数值时，对仅关键字参数的限定：

 - 位置：仅关键字参数要排在最后，顺序为：必选参数-默认值参数-可变参数-关键字参数-仅关键字参数。
 - 调用方法：必须通过关键字参数法提供参数值（如有默认值可省略）。

相对于其它解决方案，仅关键字参数在定义和调用时最灵活方便，并且能防止错误参数传入。

## 总结

python提供多种参数形式，核心目的是为了让函数能够像处理普通参数一样，方便地处理不确定数量的参数。如果调用函数前，预先将不确定数量的变量组装成序列（list/tuple）或dict，函数只通过一个序列或dict类型的普通参数接受即可。但这样做会带来两个问题：

 - 调用函数前，需要用户组装变量，多了额外步骤，不灵活。
 - list和dict作为可变对象传入，函数内部的修改会改变外部变量的值，影响重复调用。

不想用户组装变量，函数就自己通过可变参数和关键字参数将变量组装成元组。因此python给出了5种参数类型的解决方案，但由于调用函数时必须遵守“位置参数在前，关键字参数在后”的原则，5种参数类型的顺序必须为：必选参数-默认值参数-可变参数-关键字参数-仅关键字参数。
对于任意函数，都可以通过类似`func(*args, **kwargs)`的形式调用它，无论它的参数是如何定义的，因为`*args`传入前面的位置参数，`*kwargs`传入后面的关键字参数。

# 作用域（命名空间）

 - 全局作用域
 - 每个函数的局部作用域

在函数内部的局部作用域中可以访问：函数的参数和局部变量+全局作用域的全局变量（和局部变量不同名）。
函数的参数和局部变量在其自身的局部作用域中，和函数外部的全局作用域中的同名变量没有任何关系，但在函数内部会屏蔽全局作用域中的同名变量。可以使用globals()['var']引用或global关键字重新绑定全局变量。不推荐这种做法，会导致混乱和不灵活。

# 递归

> [廖雪峰：递归函数][8]

递归函数的构成：

 - 对最小可能性，函数直接返回值
 - 递归实例，包括一个或多个小规模的递归调用

递归可以用迭代（循环）代替，甚至循环的效率还更好，但递归的可读性更高！
 


  [1]: https://docs.python.org/3/library/functions.html#built-in-functions
  [2]: http://blog.csdn.net/theonegis/article/details/51013079
  [3]: http://www.cnblogs.com/loleina/p/5276918.html
  [4]: http://www.cnblogs.com/CheeseZH/p/5165283.html
  [5]: https://my.oschina.net/leejun2005/blog/145911
  [6]: http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000
  [7]: https://www.python.org/dev/peps/pep-3102/
  [8]: http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756044276a15558a759ec43de8e30eb0ed169fb11000