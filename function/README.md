tags: 函数

[TOC]

# 内置函数
> [Doc : build in functions][1]

# 参数

> [廖雪峰：函数的参数][2]
> [PEP 3102 -- Keyword-Only Arguments][3]

## 普通参数（Regular Argument）

调用函数时，传入确定数量的参数，可使用普通参数定义，在定义时明确参数的数量、类型和顺序，调用参数时，使用位置参数或者关键字参数。

### 定义函数

普通参数根据定义时是否提供默认值，可分为：

 - 必选参数：定义时不提供默认值
 - 默认参数：定义时提供默认值

参数定义顺序：必选参数在前，默认参数在后，否则python在调用函数时，无法分辨提供的参数值是用来替换前面默认参数的默认值，还是给后面的必选参数。

### 调用函数

 - 位置参数法：按照参数定义的顺序提供参数值，前面的必选参数必须提供值，后面的默认参数可省略（用默认值替代）。
 - 关键字参数法：按照`argument=value`的方式提供参数值，不必和参数定义顺序相同，但必选参数必须提供值，默认参数可省略。

位置参数法和关键字参数法可以混用（不建议），但必须保证所有位置参数在前并且和定义顺序相同，关键字参数在后，可打乱顺序。如果关键字参数后又出现位置参数，python无法分辨位置参数的正确顺序，会报错。

## 可变参数（Varargs Argument）

**参数数量不确定**，定义函数时可使用`*args`表示任意数量参数。这些参数没有参数名，无法使用关键字参数法逐个指定，只能通过位置参数法**批量处理**。

### 定义函数

定义函数时，传入的参数数量不确定，可以使用`*args`表示所有不确定的参数。可变参数中的单个参数是没有对应参数名的。在函数内部会将这些不确定的参数值组装成tuple，通过for循环逐一处理。

参数定义顺序：必选参数-默认值参数-可变参数。可变参数会“吞噬”所有传入的剩余参数值，在可变参数右侧的普通参数无法被赋值。

### 调用函数

可变参数通过`*args`定义，这些参数是没有参数名的，因此调用函数时，必须使用位置参数法。所有参数值必须按照定义顺序（必选参数-默认值参数-可变参数）严格按照位置传入，不允许在任何位置使用关键字参数，默认值参数也不能省略，即使这次调用函数使用的就是默认值，任何组合都不可以，否则都会导致python无法按正确顺序解读参数。可变参数可以看作是位置参数法对不确定数量参数的扩展。

`*args`将所有传入的参数值组装成一个tuple，可通过for循环逐一处理。如果试图直接通过传入一个list来表示多个参数，可以通过`list[index]`拆分成单一参数传入，或者可以使用`*list`方式进行解包（Unpacking Argument          Lists），解包后的单个列表元素传入函数中后，会再次被组合成tuple。

## 关键字参数（Keyword Argument）

**参数数量不确定**，但处理参数时，需要通过参数名**逐一处理**，定义函数时可使用`**kwargs`表示任意数量“参数名/参数值”对（key/value对）。例如在注册个人信息时，函数处理附加可选信息时，不但要知道参数值'beijing'，还要知道它的含义即参数名'city'。

### 定义函数

定义函数时，传入的参数数量不确定，但需要指定参数名以便逐一处理，可以使用`**kwargs`表示任意的含参数名的参数值，即“参数名/参数值”对。关键字参数中的每一个参数值都有对应参数名，在函数内部会将这些参数名和参数值组装成key/value对，保存在dict中，通过for循环逐一处理。

参数定义顺序：必选参数-默认值参数-可变参数-关键字参数。可变参数会“吞噬”所有剩余的没有参数名的参数值，关键字参数会“吞噬”可变参数后面所有有参数名的参数值。

调用函数时，必选参数，默认值参数，可变参数必须通过位置参数法调用，关键字参数必须通过关键字参数法调用，python要求所有位置参数在前，关键字参数在后，所以定义时，关键字参数必须在最后。

### 调用函数

关键字参数通过`**kwargs`定义，这些参数值都有参数名，调用函数时，必须使关键字参数法。所有参数值必须严格按照定义顺序传入（必选参数-默认值参数-可变参数-关键字参数），必选/默认值/可变参数必须使用位置参数法，关键字参数必须使用关键字参数法。这样的要求是因为可变参数没有参数名，只能通过位置调用，而python要求所有位置参数在前，关键字参数在后，所以必选/默认值/可变参数都必须使用位置调用。关键字参数可以看作是关键字参数法对不确定数量参数的扩展。

如果函数中只包含：必选参数-默认值参数-关键字参数，调用函数时，可以通过关键字参数法打乱顺序，因为所有参数都有参数名，可以准确区分。如果混用位置参数法和关键字参数法，依然要保证位置参数在前，关键字参数在后。

`**kwargs`将所有传入的“参数名/参数值”对看成一个个key/value对，在函数内部组装成dict，再通过for循环逐一处理。如果试图直接通过传入一个dict来表示多个“参数名/参数值”对，可以通过`key=dict[key]`拆分成多个“参数名/参数值”对传入，或者可以使用`**dict`方式进行解包（Unpacking Argument Lists），解包后的多个“参数名/参数值”对传入函数中后，会再次被组合成dict。

## 仅关键字参数（Keyword-Only Argument）

### 定义函数

当函数的参数具有以下两个特征时，传统的参数定义和调用会非常不方便，仅关键字参数针对这两种情况，给出两个解决方案：

 - 不确定数量的参数 + 确定数量的选项：`func(*args, arg=val)`
 可变参数`*args`后面的参数必须通过关键字参数法调用，可提供默认值。
 - 确定数量的普通参数 + 确定数量的额外选项：`func(arg1=val1, *, arg2=val2)`
 `*`后面的参数必须通过关键字参数法调用，注意*只是一个分隔符，不是参数，func()只接受两个参数。

### 调用参数

传入参数值时，对仅关键字参数的限定：

 - 位置：仅关键字参数要排在最后，顺序为：必选参数-默认值参数-可变参数-关键字参数-仅关键字参数。
 - 调用方法：必须通过关键字参数法提供参数值（如有默认值可省略）。

相对于其它解决方案，仅关键字参数在定义和调用时最灵活方便，并且能防止错误参数传入。

## 总结

python提供多种参数形式，核心目的是为了让函数能够处理不确定数量的参数。但由于调用函数时必须遵守“位置参数在前，关键字参数在后”的原则，因此5种参数类型的顺序必须为：必选参数-默认值参数-可变参数-关键字参数-仅关键字参数。
对于任意函数，都可以通过类似`func(*args, **kwargs)`的形式调用它，无论它的参数是如何定义的，因为`*args`传入前面的位置参数，`*kwargs`传入后面的关键字参数。

为什么不能用一个list或tuple表示所有可变参数呢？
定义时：list是可变对象，多次调用函数会导致list残留上一次调用的数据，tuple是不可变对象，在函数内部无法修改，成了只读参数，非常不灵活。
调用时：在函数外部需要预先将所有要传入的值组装成list或tuple，多了额外的步骤。

  [1]: https://docs.python.org/3/library/functions.html#built-in-functions
  [2]: http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000
  [3]: https://www.python.org/dev/peps/pep-3102/